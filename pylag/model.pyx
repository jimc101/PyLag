import logging

# Data types used for constructing C data structures
from pylag.data_types_python import DTYPE_INT, DTYPE_FLOAT
from data_types_cython cimport DTYPE_INT_t, DTYPE_FLOAT_t

from pylag.integrator import get_num_integrator
from pylag.random_walk import get_vertical_random_walk_model, get_horizontal_random_walk_model
from pylag.particle_positions_reader import read_particle_initial_positions
from pylag.particle import ParticleSmartPtr

from libcpp.vector cimport vector

from pylag.data_reader cimport DataReader, sigma_to_cartesian_coords, cartesian_to_sigma_coords
from pylag.integrator cimport NumIntegrator
from pylag.random_walk cimport VerticalRandomWalk, HorizontalRandomWalk
from pylag.delta cimport Delta, reset
from pylag.particle cimport Particle, copy

cdef class OPTModel:
    def set_particle_data(self, group_ids, x_positions, y_positions, z_positions):
        pass
    
    def setup_input_data_access(self, start_datetime, end_datetime):
        pass

    def read_input_data(self, time):
        pass

    def seed(self, time):
        pass
    
    def update(self, time):
        pass
    
    def get_diagnostics(self, time):
        pass
    
cdef class FVCOMOPTModel(OPTModel):
    """ FVCOM Offline Particle Tracking Model.
    
    Offline particle tracking moodel implementation that is tailored to work 
    with data generated by the FVCOM.
    
    Parameters:
    -----------
    config : SafeConfigParser
        Configuration obect.
    
    data_reader : FVCOMDataReader
        FVCOM data reader.
    """
    cdef object config
    cdef DataReader data_reader
    cdef NumIntegrator num_integrator
    cdef VerticalRandomWalk vert_rand_walk_model
    cdef HorizontalRandomWalk horiz_rand_walk_model
    cdef object particle_seed_smart_ptrs
    cdef object particle_smart_ptrs
    cdef vector[Particle*] particle_ptrs
    
    # Seed particle data (as read from file)
    cdef DTYPE_INT_t[:] _group_ids
    cdef DTYPE_FLOAT_t[:] _x_positions
    cdef DTYPE_FLOAT_t[:] _y_positions
    cdef DTYPE_FLOAT_t[:] _z_positions

    def __init__(self, config, data_reader, *args, **kwargs):
        # Initialise config
        self.config = config

        # Initialise model data reader
        self.data_reader = data_reader
        
        # Create numerical integrator
        self.num_integrator = get_num_integrator(self.config)

        # Create vertical random walk model
        self.vert_rand_walk_model = get_vertical_random_walk_model(self.config)

        # Create horizontal random walk model
        self.horiz_rand_walk_model = get_horizontal_random_walk_model(self.config)

    def set_particle_data(self, group_ids, x_positions, y_positions, z_positions):
        """Initialise memory views for data describing the particle seed.

        Parameters:
        -----------
        group_ids : ndarray, int
            Particle groups IDs.

        x_positions : ndarray, float
            Particle x-positions.

        y_positions : ndarray, float
            Particle y-positions.

        z_positions : ndarray, float
            Particle z-positions.
        """
        self._group_ids = group_ids
        self._x_positions = x_positions
        self._y_positions = y_positions
        self._z_positions = z_positions

    def setup_input_data_access(self, start_datetime, end_datetime):
        """Setup access to FVCOM time dependent variables.

        Parameters:
        -----------
        start_datime : Datetime
            The simulation start date and time.

        end_datime : Datetime
            The simulation end date and time.
        """
        self.data_reader.setup_data_access(start_datetime, end_datetime)

    def read_input_data(self, time):
        """Update reading frames for FVCOM data fields.

        Parameters:
        -----------
        time : float
            The current time.
        """
        self.data_reader.read_data(time)

    def seed(self, time=None):
        """Set particle positions equal to those of the particle seed.
        
        Create the particle seed if it has not been created already. Make
        an `active' copy of the particle seed.

        Parameters:
        -----------
        time : float
            The current time.
        """
        if self.particle_seed_smart_ptrs is None:
            self._create_seed(time)

        # Destroy the current active particle set and all pointers to it
        self.particle_smart_ptrs = []
        self.particle_ptrs.clear()

        for particle_seed_smart_ptr in self.particle_seed_smart_ptrs:
            particle_smart_ptr = copy(particle_seed_smart_ptr)
            self.particle_smart_ptrs.append(particle_smart_ptr)
            self.particle_ptrs.push_back(particle_smart_ptr.get_ptr())

    def _create_seed(self, time):
        """Create the particle seed.
        
        Create the particle seed using the supplied arguments. Initialise
        `particle_set' using `particle_seed'. A separate copy of the particle
        seed is stored so that the model can be reseeded at a later time, as
        required.

        Parameters:
        -----------
        time : float
            The current time.        
        """
        # Grid boundary limits
        cdef DTYPE_FLOAT_t zmin
        cdef DTYPE_FLOAT_t zmax
        
        # Create particle seed - particles stored in a list object
        self.particle_seed_smart_ptrs = []

        guess = None
        particles_in_domain = 0
        for group, x, y, z_temp in zip(self._group_ids, self._x_positions, self._y_positions, self._z_positions):
            # Find particle host element
            if guess is not None:
                # Try a local search first
                host_horizontal_elem = self.data_reader.find_host_using_local_search(x, y, guess)
                if host_horizontal_elem < 0:
                    # Local search failed - try a global search
                    host_horizontal_elem = self.data_reader.find_host_using_global_search(x, y)
            else:
                # Global search ...
                host_horizontal_elem = self.data_reader.find_host_using_global_search(x, y)

            if host_horizontal_elem >= 0:
                in_domain = True

                # Set z depending on the specified coordinate system
                if self.config.get("SIMULATION", "depth_coordinates") == "cartesian":
                    # z is given as the distance below the free surface. We use
                    # this and zeta to determine the distance below the mean
                    # free surface, which is then used with h to calculate sigma
                    h = self.data_reader.get_bathymetry(x, y, host_horizontal_elem)
                    zeta = self.data_reader.get_sea_sur_elev(time, x, y, host_horizontal_elem)

                    z = z_temp + zeta
                    sigma = cartesian_to_sigma_coords(z, h, zeta)
                    
                elif self.config.get("SIMULATION", "depth_coordinates") == "sigma":
                    # sigma ranges from 0.0 at the sea surface to -1.0 at the 
                    # sea floor.
                    sigma = z_temp
                
                # Check that the given depth is valid
                zmin = self.data_reader.get_zmin(time, x, y)
                zmax = self.data_reader.get_zmax(time, x, y)
                if sigma < zmin:
                    raise ValueError("Supplied depth z (= {}) lies below the sea floor (h = {}).".format(z,h))
                elif sigma > zmax:
                    raise ValueError("Supplied depth z (= {}) lies above the free surface (zeta = {}).".format(z,zeta))

                # Create particle
                particle_seed_smart_ptr = ParticleSmartPtr(group, x, y, sigma, host_horizontal_elem, in_domain=in_domain)
                self.particle_seed_smart_ptrs.append(particle_seed_smart_ptr)

                particles_in_domain += 1

                # Use the location of the last particle to guide the search for the
                # next. This should be fast if particle initial positions are colocated.
                guess = host_horizontal_elem
            else:
                in_domain = False
                particle_seed_smart_ptr = ParticleSmartPtr(group_id=group, in_domain=in_domain)
                self.particle_seed_smart_ptrs.append(particle_seed_smart_ptr)

        if self.config.getboolean('GENERAL', 'full_logging'):
            logger = logging.getLogger(__name__)
            logger.info('{} of {} particles are located in the model domain.'.format(particles_in_domain, len(self.particle_seed)))

    def update(self, DTYPE_FLOAT_t time):
        """ Compute and update each particle's position.
        
        Compute the net effect of resolved and unresolved processes on particle
        motion in the interval t -> t + dt. Resolved velocities are used to
        advect particles. A random displacement model is used to model the
        effect of unresolved (subgrid scale) vertical and horizontal transport
        processes. Particle displacements are first stored and accumulated in an
        object of type Delta before then being used to update a given particle's
        position.
        
        If a particle crosses a land boundary its motion is temporarily
        arrested. If the particle crosses an open boundary it is flagged as
        having left the domain. These checks are performed twice - the first
        after the advection call and the second after the net effect of each
        process has been summed. The former is implemented in order to catch
        errors thrown by the numerical integration scheme - these often employ
        multi-step process which will error if the particle exits the domain 
        mid-way through the computation.
        
        In the vertical, reflecting boundary conditions are applied at the 
        bottom and surface boundaries.
        
        Parameters:
        -----------
        time : float
            The current time.
        """
        cdef DTYPE_FLOAT_t xpos, ypos, zpos
        cdef DTYPE_FLOAT_t zmin, zmax
        cdef Delta delta_X
        cdef Particle* particle_ptr
        cdef DTYPE_INT_t host, host_err
        cdef DTYPE_INT_t i, n_particles
        
        # Cycle over the particle set, updating the position of only those
        # particles that remain in the model domain
        for particle_ptr in self.particle_ptrs:
            if particle_ptr.in_domain:
                reset(&delta_X)
                
                # Advection
                if self.num_integrator is not None:
                    host_err = self.num_integrator.advect(time,
                            particle_ptr, self.data_reader, &delta_X)
                            
                    # Check for boundary crossings. These are checked for
                    # a second time at the end of the update loop.
                    if host_err == -1:
                        continue
                    elif host_err == -2:
                        particle_ptr.in_domain = False
                        continue
                
                # Vertical random walk
                if self.vert_rand_walk_model is not None:
                    self.vert_rand_walk_model.random_walk(time, particle_ptr, 
                            self.data_reader, &delta_X)

                # Horizontal random walk
                if self.horiz_rand_walk_model is not None:
                    self.horiz_rand_walk_model.random_walk(time, particle_ptr, 
                            self.data_reader, &delta_X)  
                
                # Sum contributions
                xpos = self.particle_ptr.xpos + delta_X.x
                ypos = self.particle_ptr.ypos + delta_X.y
                zpos = self.particle_ptr.zpos + delta_X.z
                host = self.data_reader.find_host(xpos, ypos, particle_ptr.host_horizontal_elem)
              
                # If the particle still resides in the domain update its
                # position. If the particle has crossed a land boundary arrest
                # its position. If it has crossed an open boundary flag it as
                # having left the model domain.
                if host >= 0:
                    # Apply reflecting surface/bottom boundary conditions
                    zmin = self.data_reader.get_zmin(time, xpos, ypos)
                    zmax = self.data_reader.get_zmax(time, xpos, ypos)
                    if zpos < zmin:
                        zpos = zmin + zmin - zpos
                    elif zpos > zmax:
                        zpos = zmax + zmax - zpos

                    # Check for valid zpos
                    if zpos < zmin:
                        raise ValueError("New zpos (= {}) lies below the sea floor.".format(zpos))
                    elif zpos > zmax:
                        raise ValueError("New zpos (= {}) lies above the free surface.".format(zpos))                

                    # Update the particle's position
                    particle_ptr.xpos = xpos
                    particle_ptr.ypos = ypos
                    particle_ptr.zpos = zpos
                    particle_ptr.host_horizontal_elem = host
                elif host == -1:
                    # Land boundary crossed - do nothing.
                    continue
                elif host == -2:
                    # Open boundary crossed - flag as having left the domain.
                    particle_ptr.in_domain = False
                    continue
                else:
                    raise ValueError('Unrecognised host element {}.'.format(host))

    def get_diagnostics(self, time):
        """ Get particle diagnostics
        
        Parameters:
        -----------
        time : float
            The current time.
        
        Returns:
        --------
        diags : dict
            Dictionary holding particle diagnostic data.
        """
        cdef Particle* particle_ptr
        
        diags = {'xpos': [], 'ypos': [], 'zpos': [], 'host_horizontal_elem': [], 'h': [], 'zeta': []}
        for particle_ptr in self.particle_ptrs:
            diags['xpos'].append(particle_ptr.xpos)
            diags['ypos'].append(particle_ptr.ypos)
            diags['host_horizontal_elem'].append(particle_ptr.host_horizontal_elem)            
            
            # Derived vars including depth, which is first converted to cartesian coords
            h = self.data_reader.get_bathymetry(particle_ptr.xpos, particle_ptr.ypos, particle_ptr.host_horizontal_elem)
            zeta = self.data_reader.get_sea_sur_elev(time, particle_ptr.xpos, particle_ptr.ypos, particle_ptr.host_horizontal_elem)
            z = sigma_to_cartesian_coords(particle_ptr.zpos, h, zeta)
            diags['h'].append(h)
            diags['zeta'].append(zeta)
            diags['zpos'].append(z)
        return diags

cdef class GOTMOPTModel(OPTModel):
    """ GOTM Offline Particle Tracking Model.
    
    Offline particle tracking model implementation that is tailored to work 
    with data generated by the GOTM.
    
    Parameters:
    -----------
    config : SafeConfigParser
        Configuration obect.
    
    data_reader : GOTMDataReader
        GOTM data reader.
    """
    cdef object config
    cdef DataReader data_reader
    cdef VerticalRandomWalk vert_rand_walk_model
    cdef object particle_seed_smart_ptrs
    cdef object particle_smart_ptrs
    cdef vector[Particle*] particle_ptrs
    
    # Seed particle data (as read from file)
    cdef DTYPE_INT_t[:] _group_ids
    cdef DTYPE_FLOAT_t[:] _x_positions
    cdef DTYPE_FLOAT_t[:] _y_positions
    cdef DTYPE_FLOAT_t[:] _z_positions

    def __init__(self, config, data_reader, *args, **kwargs):
        # Initialise config
        self.config = config

        # Initialise model data reader
        self.data_reader = data_reader

        # Create vertical random walk model
        self.vert_rand_walk_model = get_vertical_random_walk_model(self.config)

    def set_particle_data(self, group_ids, x_positions, y_positions, z_positions):
        """Initialise memory views for data describing the particle seed.

        Parameters:
        -----------
        group_ids : ndarray, int
            Particle groups IDs.

        x_positions : ndarray, float
            Particle x-positions.

        y_positions : ndarray, float
            Particle y-positions.

        z_positions : ndarray, float
            Particle z-positions.
        """
        self._group_ids = group_ids
        self._x_positions = x_positions
        self._y_positions = y_positions
        self._z_positions = z_positions

    def setup_input_data_access(self, start_datetime, end_datetime):
        """Setup access to FVCOM time dependent variables.

        Parameters:
        -----------
        start_datime : Datetime
            The simulation start date and time.

        end_datime : Datetime
            The simulation end date and time.
        """
        self.data_reader.setup_data_access(start_datetime, end_datetime)

    def read_input_data(self, time):
        """Update reading frames for FVCOM data fields.

        Parameters:
        -----------
        time : float
            The current time.
        """
        self.data_reader.read_data(time)

    def seed(self, time=None):
        """Set particle positions equal to those of the particle seed.
        
        Create the particle seed if it has not been created already. Make
        an `active' copy of the particle seed.

        Parameters:
        -----------
        time : float
            The current time.
        """
        if self.particle_seed_smart_ptrs is None:
            self._create_seed(time)

        # Destroy the current active particle set and all pointers to it
        self.particle_smart_ptrs = []
        self.particle_ptrs.clear()

        for particle_seed_smart_ptr in self.particle_seed_smart_ptrs:
            particle_smart_ptr = copy(particle_seed_smart_ptr)
            self.particle_smart_ptrs.append(particle_smart_ptr)
            self.particle_ptrs.push_back(particle_smart_ptr.get_ptr())

    def _create_seed(self, time):
        """Create the particle seed.
        
        Create the particle seed using the supplied arguments. Initialise
        `particle_set' using `particle_seed'. A separate copy of the particle
        seed is stored so that the model can be reseeded at a later time, as
        required.

        Parameters:
        -----------
        time : float
            The current time.        
        """
        # Create particle seed - particles stored in a list object
        self.particle_seed_smart_ptrs = []
        for group, x, y, z_temp in zip(self._group_ids, self._x_positions,
                self._y_positions, self._z_positions):
            # Particle in the domain - this is a 1D column model.
            in_domain = True
            
            # Host set to 0
            host = 0

            # Set z depending on the specified coordinate system
            if self.config.get("SIMULATION", "depth_coordinates") == "cartesian":
                # z is given as the distance below the free surface. We use
                # this and zeta to determine the distance below the mean
                # free surface, which is then used with h to calculate sigma
                h = self.data_reader.get_bathymetry(x, y, host)
                zeta = self.data_reader.get_sea_sur_elev(time, x, y, host)

                z = z_temp + zeta
                sigma = cartesian_to_sigma_coords(z, h, zeta)

            elif self.config.get("SIMULATION", "depth_coordinates") == "sigma":
                # sigma ranges from 0.0 at the sea surface to -1.0 at the 
                # sea floor.
                sigma = z_temp

            # Check that the given depth is valid
            zmin = self.data_reader.get_zmin(time, x, y)
            zmax = self.data_reader.get_zmax(time, x, y)
            if sigma < zmin:
                raise ValueError("Supplied depth z (= {}) lies below the sea floor (h = {}).".format(sigma,zmin))
            elif sigma > zmax:
                raise ValueError("Supplied depth z (= {}) lies above the free surface (zeta = {}).".format(sigma,zmax))

            # Find the host z layer
            z_layer = self.data_reader.find_zlayer(time, x, y, sigma, host, 0)

            # Create particle
            particle_seed_smart_ptr = ParticleSmartPtr(group, x, y, sigma, host, z_layer, in_domain)
            self.particle_seed_smart_ptrs.append(particle_seed_smart_ptr)

    def update(self, DTYPE_FLOAT_t time):
        """ Compute and update each particle's position.
        
        Reflecting boundary conditions are applied at the bottom and surface
        boundaries.
        
        Parameters:
        -----------
        time : float
            The current time.
        """
        cdef DTYPE_FLOAT_t xpos, ypos, zpos

        cdef DTYPE_FLOAT_t zmin, zmax

        cdef Delta delta_X

        cdef Particle* particle_ptr

        cdef DTYPE_INT_t i, n_particles

        # Cycle over the particle set, updating the position of only those
        # particles that remain in the model domain
        for particle_ptr in self.particle_ptrs:
            if particle_ptr.in_domain:
                reset(&delta_X)
                
                # Vertical random walk
                if self.vert_rand_walk_model is not None:
                    self.vert_rand_walk_model.random_walk(time, particle_ptr, 
                            self.data_reader, &delta_X)

                # Sum contributions
                zpos = particle_ptr.zpos + delta_X.z

                # Apply reflecting surface/bottom boundary conditions
                zmin = self.data_reader.get_zmin(time, 0.0, 0.0)
                zmax = self.data_reader.get_zmax(time, 0.0, 0.0)
                if zpos < zmin:
                    zpos = zmin + zmin - zpos
                elif zpos > zmax:
                    zpos = zmax + zmax - zpos

                # Check for valid zpos
                if zpos < zmin:
                    raise ValueError("New zpos (= {}) lies below the sea floor.".format(zpos))
                elif zpos > zmax:
                    raise ValueError("New zpos (= {}) lies above the free surface.".format(zpos))                

                # Find the new host z layer using the old host z layer
                xpos = particle_ptr.xpos
                ypos = particle_ptr.ypos
                host_horizontal_elem = particle_ptr.host_horizontal_elem
                old_host_z_layer = particle_ptr.host_z_layer
                
                host_z_layer = self.data_reader.find_zlayer(time, xpos, ypos, 
                    zpos, host_horizontal_elem, old_host_z_layer)

                # Update the particle's position and the host z layer
                particle_ptr.zpos = zpos
                particle_ptr.host_z_layer = host_z_layer

    def get_diagnostics(self, time):
        """ Get particle diagnostics
        
        Parameters:
        -----------
        time : float
            The current time.
        
        Returns:
        --------
        diags : dict
            Dictionary holding particle diagnostic data.
        """
        cdef Particle* particle_ptr
        
        diags = {'xpos': [], 'ypos': [], 'zpos': [], 'host_horizontal_elem': [], 'h': [], 'zeta': []}
        for particle_ptr in self.particle_ptrs:
            diags['xpos'].append(particle_ptr.xpos)
            diags['ypos'].append(particle_ptr.ypos)
            diags['host_horizontal_elem'].append(particle_ptr.host_horizontal_elem)            
            
            # Derived vars including depth, which is first converted to cartesian coords
            h = self.data_reader.get_bathymetry(particle_ptr.xpos, particle_ptr.ypos, particle_ptr.host_horizontal_elem)
            zeta = self.data_reader.get_sea_sur_elev(time, particle_ptr.xpos, particle_ptr.ypos, particle_ptr.host_horizontal_elem)
            z = sigma_to_cartesian_coords(particle_ptr.zpos, h, zeta)
            diags['h'].append(h)
            diags['zeta'].append(zeta)
            diags['zpos'].append(z)
        return diags
